/**
 * The Render Engine
 * BaseObject
 *
 * Copyright (c) 2008-2018 Brett Fattori (bfattori@gmail.com)
 */
"use strict";

/**
 * @class The base object class which represents an object within
 * the engine.  Objects of this type can have an associated DOM element,
 * and will also inherit the {@link #update} method to perform processing
 * for every frame generated.
 * <p/>
 * This object also enhances the event handling provided by the {@link R.engine.Events event engine}.
 * It will remember events assigned to the object so that they can be automatically
 * cleaned up when the object is destroyed.
 * <p/>
 * If you are working with an object that represents an HTML element (node),
 * this object is ideal to extend from.  It has methods for assigning and
 * accessing that element.
 * <p/>
 * The {@link #update} method is called each time a frame is generated by the engine
 * to update the object within the scene graph. In this method, you'll be able to
 * update the internals of the object and perform general housekeeping.
 *
 * @param name {String} The name of the object
 * @extends R.engine.PooledObject
 * @constructor
 * @description Create a base object.
 */
class BaseObject extends PooledObject {

  /** @private */
  constructor(name) {
    super(name);
    this.events = {};
    this.eventListeners = {};
  }

  /**
   * Destroy the object, cleaning up any events that have been
   * attached to this object.  Calls the <tt>destroy</tt> event
   * before the object is destroyed.
   */
  destroy() {
    // Trigger the "destroy" event before the object is destroyed
    this.triggerEvent("destroyed");

    // Clean up non-element event listeners
    this.eventListeners = {};

    super.destroy();
  }

  /**
   * Release the object back into the object pool.
   */
  release() {
    super.release();
    this.events = null;
    this.eventListeners = null;
  }

  /**
   * Abstract update method to set the state of the object.  This method
   * will be called each frame that is generated by the engine.  The
   * context where the object will be rendered is passed, along with the
   * current engine time.  Use this method to update components and
   * perform housekeeping on the object.
   *
   * @param time {Number} The current engine time, in milliseconds
   * @param dt {Number} The delta between the world time and the last time the world was updated
   *          in milliseconds.
   */
  update(time, dt) {
  }

  /**
   * Abstract method to render the object.
   */
  render() {
  }

  /**
   * Add an event handler to this object. Within the
   * event handler, <tt>this</tt> refers to the object upon which the event is being triggered. It is
   * possible to bind an event simply by calling <tt>addEvent</tt> with the type and callback, like
   * so:
   * <pre>
   *    this.addEvent("click", function(evt) {
       *       this.doSomething(evt);
       *    });
   * </pre>
   * However, if you need to reference another object during the binding process, such as when
   * a render context is binding an event to a game object, you could pass a reference object
   * as the first argument:
   * <pre>
   *    // "this" refers to the render context
   *    someObj.addEvent(this, "click", function(evt) {
       *       // Inside the handler, "this" is the target of the event
       *       this.doSomething(evt);
       *    });
   * </pre>
   * The purpose behind this is that if the render context assigned the event, it should
   * probably remove the handler, rather than the game object needing to remove the handler.
   * But, if the game object <i>also</i> has a "click" handler, you don't want to remove
   * <i>that handler</i> since the game object may still need it.
   * <p/>
   * If the event handler explicitly returns <code>false</code> (not <code>null</code>, or
   * <code>undefined</code>), further event handlers will not be processed.
   *
   * @param [ref] {Object} The object reference which is assigning the event
   * @param type {String} The event type to respond to
   * @param [data] {Array} Optional data to pass to the handler when it is invoked.
   * @param fn {Function} The function to trigger when the event fires
   */
  addEvent(ref, type, data, fn) {

    // CAUTION: Brain Teaser
    fn = R.isString(ref) ? (R.isFunction(type) ? type : (R.isFunction(data) ? data : fn)) :
      R.isFunction(data) ? data : fn;
    data = R.isString(ref) ? (R.isFunction(type) ? null : (R.isFunction(data) ? null : data)) :
      R.isFunction(data) ? null : data;
    type = R.isString(ref) ? ref : type;
    ref = R.isString(ref) ? this : ref;
    // CAUTION -------------

    if (ref == null) {
      // This is a global assignment to the document body.  Many listeners
      // may collect data from the event handler.
      console.info("Global assignment of event: ", type);
      R.engine.Events.setHandler(document.body, type, data || fn, fn);
      //this.events["document," + type] = fn;
    }
    else {
      console.debug("BaseObject(", ref.getName(), " attach event: ", type, " to ", this.name);
      if (this.getElement() && ref instanceof R.rendercontexts.AbstractRenderContext) {
        R.engine.Events.setHandler(this.getElement(), type, data || fn, fn);

        // Remember the handler by the reference object's name and event type
        this.events[ref.getName() + "," + type] = fn;
      } else {
        // We want to be able to add event handlers to objects which don't
        // have an element associated with them as well
        var listeners = this.eventListeners[type.toUpperCase()];
        if (!listeners) {
          listeners = this.eventListeners[type.toUpperCase()] = [];
        }

        // Add the new listener
        listeners.push({
          id: ref.name() + "," + type,
          data: data,
          callback: fn
        });
      }
    }
  }

  /**
   * Helper method to simplify wiring event handlers to event types.  You can assign
   * multiple handlers, by name, using object or array notation, for example:
   * <pre>
   *    // Shorthand
   *    this.addEvents({
       *       "keydown": function(evt, which) {
       *          this.onKeyDown(which);
       *       },
       *       "keyup": function(evt, which) {
       *          this.onKeyUp(which);
       *       }
       *    });
   *
   *    // Super shorthand
   *    this.addEvents(["onKeyDown", "onKeyUp"]);
   * </pre>
   * Object notation allows you to still be explicit in which handler method to
   * apply or call, and the arguments which are handled.  Array notation will
   * simply create a method call which takes the names of the event handlers,
   * removes "on" and then lower cases the remainder to create the event assignment.
   * <p/>
   * In the example above, <tt>onKeyDown</tt> is the name of your method to be
   * called, and <tt>keydown</tt> will be the name of the actual event.
   *
   * @param handlers {Object|Array} The event assignments
   */
  addEvents(handlers) {
    var self = this;
    if (R.isArray(handlers)) {
      for (var h = 0; h < handlers.length; h++) {
        var method = this[handlers[h]];
        this.addEvent(handlers[h].substr(2).toLowerCase(), method);
      }
    } else {
      $.each(handlers, function (key, value) {
        self.addEvent(key, value);
      });
    }
  }

  /**
   * Remove the event handler assigned to the object for the given type.  The optional
   * <tt>ref</tt> argument is used when another object assigned the event handler, such as:
   * <pre>
   *    // Handler #1
   *    someObject.addEvent("click", function(evt) {
       *       this.doSomething(evt);
       *    });
   *
   *    // Handler #2
   *    someObject.addEvent(anotherObject, "click", function(evt) {
       *       this.doSomething(evt);
       *    });
   * </pre>
   * You would remove the "click" handler that <tt>anotherObject</tt> assigned (handler #2),
   * and not one that was bound by <tt>someObject</tt> (handler #1):
   * <pre>
   *    someObject.removeEvent(anotherObject, "click");
   * </pre>
   *
   * @param [ref] {Object} The object reference which assigned the event
   * @param type {String} The event type to remove
   */
  removeEvent(ref, type) {
    var fn;
    ref = R.isString(ref) ? this : ref;
    if (ref == null) {
      // This was a global assignment to the document body.  Clean it up
      console.info("GLOBAL event: ", type, " removed");
      fn = this.events["document," + type];
      R.engine.Events.clearHandler(document.body, type, fn);
    }
    else {
      R.debug.Console.info(ref.getName() + " remove event '" + type + "' from " + this.getName());
      var id = ref.getName() + "," + type;
      if (this.getElement() && ref instanceof R.rendercontexts.AbstractRenderContext) {
        // Find the handler to remove
        fn = this.events[id];
        if (fn) {
          R.engine.Events.clearHandler(this.getElement(), type, fn);
        }
        // Remove the reference
        delete this.events[ref.getName() + "," + type];
      } else {
        var listeners = this.eventListeners[type.toUpperCase()];
        if (listeners) {
          listeners = RenderEngine.Support.filter(listeners, function (e) {
            return e.id !== id;
          });
        }
      }
    }
  }

  /**
   * Trigger an event on the object.  Event handlers assigned with
   * {@link #addEvent} will be triggered and passed the event object
   * and the data.  The scope of the listener function will be the
   * object.
   *
   * @param eventName {String} The event to trigger
   * @param [eventObj] {Event} The original event object
   * @param data {Array} An array of data to pass to the event handler
   */
  triggerEvent(eventName, eventObj, data) {
    var ret;
    if (this.getElement() && this instanceof R.rendercontexts.AbstractRenderContext) {
      if (eventObj && (eventObj instanceof Event)) {
        ret = this.jQ().trigger(eventObj);
      } else {
        ret = this.jQ().trigger(eventName, eventObj);
      }
      return ret
    } else {
      if (this.eventListeners) {
        var listeners = this.eventListeners[eventName.toUpperCase()];
        if (listeners) {
          if (eventObj && R.isArray(eventObj)) {
            data = eventObj;
            eventObj = $.Event({type: eventName});
          }
          data = data || [];

          // Make sure the first element is the event
          data.unshift(eventObj);

          for (var e = 0; e < listeners.length; e++) {
            var listener = listeners[e];

            // Append the predefined listener data to the data object
            if (listener.data) {
              data = data.concat(listener.data);
            }

            // Call the listener
            ret = listener.callback.apply(this, data);
            if (ret === false) {
              return false;
            }
          }
        }
      }
    }
  }

  /**
   * Get the class name of this object
   *
   * @return {String} "R.engine.BaseObject"
   */
  get className() {
    return "BaseObject";
  }

}