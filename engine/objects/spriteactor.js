/**
 * The Render Engine
 * SpriteActor
 *
 * Copyright (c) 2018 Brett Fattori (bfattori@gmail.com)
 */
"use strict";

/**
 * @class A <tt>SpriteActor</tt> is an actor object within a game, whose renderer
 *          is a 2D sprite.  It can have actions assigned to it, which are triggered
 *          by either a controlling player or generated by the program.
 * @param name {String} The name of the object
 * @extends R.objects.Object2D
 * @constructor
 * @description Create a sprite actor
 */
class SpriteActor extends Object2D {

  constructor(name = "SpriteActor", tileMap) {
    super(name, PlatformMover2DComponent.create("move", tileMap));

    this.actorId = "";
    this.collisionMask = "0";
    this.scriptedActions = {};
    this.scriptedVars = {};

    this.collidable = false;

    // Add sprite component to draw the player
    this.add(SpriteComponent.create("draw"));
  }

  /**
   * After the actor is added to the context, allow it a chance to initialize.
   * @private
   */
  afterAdd(parent) {
    super.afterAdd(parent);
    this.callScriptedEvent("onInit", []);
  }

  /**
   * Destroy the object
   */
  destroy() {
    this.callScriptedEvent("onDestroy", []);
    super.destroy();
  }

  /**
   * Release the object back into the pool.
   */
  release() {
    super.release();

    // TODO: There should be cleanup, no?
    this.scriptedActions = null;
    this.scriptedVars = null;
  }

  /**
   * Get the class name of this object
   * @return The string <tt>R.objects.SpriteActor</tt>
   * @type String
   */
  get className() {
    return "SpriteActor";
  }

  set tileMap(tileMap) {
    this.components("move").tileMap = tileMap;
  }

  get tileMap() {
    return this.components("move").tileMap;
  }

  /**
   * Get a properties object for this sprite actor
   * @return {Object}
   */
  getProperties() {
    var props = super.getProperties();
    props.add("Sprite", [
      function () {
        return this.sprite.spriteResource[resourceName + ":" + self.sprite.name];
      }.bind(this),
      null
    ]);
    props.add("Collidable", [
      function () {
        return this.collidable;
      }.bind(this),
      function (c) {
        this.collidable = c;
      }
    ]);
  }

  /**
   * Set the actor's Id which can be looked up with {@link R.objects.SpriteActor#findActor}
   * @param actorId {String} A unique Id to reference this object
   */
  set actorId(actorId) {
    this._actorId = actorId;
  }

  /**
   * Get the actor's unique Id which references this object
   * @return {String}
   */
  get actorId() {
    return this._actorId;
  }

  /**
   * Set the collision bitmask for this object
   * @param collisionMask {String} A binary string of ones and zeros
   */
  set collisionMask(collisionMask) {
    this._collisionMask = collisionMask;
  }

  /**
   * Get the collision bitmask for this object
   * @return {String}
   */
  get collisionMask() {
    return this._collisionMask;
  }

  /**
   * Get the event associated with the action name.
   */
  get actorEvents() {
    return this.scriptedActions;
  }

  /**
   * Set the event handler for the action name.
   * @param {String} actionName
   * @param {Object} script
   */
  setActorEvent(actionName, script) {
    this.scriptedActions[actionName] = {"script": script};
  }

  /**
   * Calls a scripted event.  The event handler will be compiled to include the
   * variables and then called in the scope of this actor.
   * @param eventName {String} The name of the event to call
   * @param argNames {Array} An array of argument names to map the arguments array to (1:1)
   * @param args {Array} The array of arguments to pass to the event handler
   * @private
   */
  callScriptedEvent(eventName, argNames, args) {
    var eScript = this.actorEvents(eventName);
    if (R.isEmpty(eScript)) {
      return;
    }

    if (eScript.compiled) {
      // Use the compiled version
      eScript = eScript.compiled;
    } else {
      // Compile the script, injecting the variables
      var varScript = "";
      for (var a in argNames) {
        varScript += "var " + argNames[a] + "=arguments[" + a + "]; ";
      }
      eScript = this.scriptedActions[eventName].compiled = new Function(varScript + eScript.script);
    }

    return eScript.apply(this, args);
  }

  /**
   * Get the value of the specified variable.
   */
  get variables() {
    return this.scriptedVars;
  }

  /**
   * Set the value of the specified variable.
   * @param varName {String} The name of the variable
   * @param value {Object} The value to assign to the variable
   */
  setVariable(varName, value) {
    this.scriptedVars[varName] = value;
  }

  /**
   * Get the events object for this actor.  The configuration is a
   * collection of variables and scripts which are used to run the actor.  When
   * scripts are called, the scope of the callback is the actor.  The following are
   * included:
   * <ul>
   * <li>onInit() - Called when the actor is added to the level</li>
   * <li>onDestroy() - Called when the actor is removed from the level</li>
   * <li>onCollide(collisionData, targetMask, worldTime) - Called when the actor collides with another object.  The data
   *     contains information about the collision. See: {@link R.struct.CollisionData}  The mask is the target's
   *     collision bitmask, and the time is the world time when the collision occurred.</li>
   * <li>onVisibility(state) - Called when the actor enters or leaves the frame.  The state
   *     will be <tt>true</tt> when visible (rendered).</li>
   * <li>onBeforeUpdate(worldTime) - Called before the actor is updated, providing the world time.</li>
   * <li>onAfterUpdate(worldTime) - Called after the actor is updated, providing the world time.</li>
   * </ul>
   *
   * @return {Object}
   */
  get config() {
    // name : type (script|var)
    var cfg = {
      "onInit": "script",
      "onDestroy": "script",
      "onCollide": "script",
      "onCollideWorld": "script",
      "onVisibility": "script",
      "onBeforeUpdate": "script",
      "onAfterUpdate": "script"
    };
  }


  /**
   * Update the player within the rendering context.  This draws
   * the shape to the context, after updating the transform of the
   * object.  If the player is thrusting, draw the thrust flame
   * under the ship.
   *
   * @param renderContext {R.rendercontexts.AbstractRenderContext} The rendering context
   * @param time {Number} The engine time in milliseconds
   * @param dt {Number} The delta between the world time and the last time the world was updated
   *          in milliseconds.
   */
  update(renderContext, time, dt) {
    renderContext.pushTransform();

    this.callScriptedEvent("onBeforeUpdate", ["worldTime", "delta"], [time, dt]);
    super.update(renderContext, time, dt);
    this.callScriptedEvent("onAfterUpdate", ["worldTime", "delta"], [time, dt]);

    var bBox = this.boundingBox,
      pos = R.clone(this.position),
      moveVec = this.getComponent("move").moveVector,
      testPt = R.clone(bBox.getCenter()).add(pos),
      mNormal = R.clone(moveVec).normalize(),
      rayInfo,
      dir = Vector2D.create(0, 0);

    // If movement isn't zero, we want to test for collisions along the vector.
    // We'll cast a ray in the direction of movement, one tile width long, from the center of the
    // bounding box (yes, this looks familiar for a reason...)
    if (moveVec.length != 0) {
      // We want to cast a ray along the axis of movement
      testPt.x = testPt.x + (bBox.getHalfWidth() * mNormal.x);
      dir.x = moveVec.x;
      dir.y = moveVec.y;
      dir.normalize().mul(this.getComponent("move").getTileSize());

      rayInfo = RayInfo.create(testPt, dir);

      TileMap.castRay(this.tileMap, rayInfo, renderContext);

      // There's something in the direction of movement, call the scripted action for "onCollideWorld"
      if (rayInfo.shape) {
        var dist = Vector2D.create(rayInfo.impactPoint).sub(testPt);
        this.callScriptedEvent("onCollideWorld",
          ["tile", "impactPoint", "distance", "worldTime", "delta"],
          [rayInfo.shape, rayInfo.impactPoint, dist.len(), time, dt]);
        dist.destroy();
      }

      rayInfo.destroy();
    }

    dir.destroy();
    pos.destroy();
    mNormal.destroy();
    testPt.destroy();

    //renderContext.setLineStyle("white");
    //renderContext.setLineWidth(2);
    //var bbox = R.math.Rectangle2D.create(this.getSprite().getBoundingBox());
    //var o = R.math.Point2D.create(this.getOrigin());
    //o.neg();
    //bbox.offset(o);
    //renderContext.drawRectangle(bbox);
    //bbox.destroy();
    //o.destroy();

    renderContext.popTransform();
  }

  /**
   * Set a flag which will determine if the actor will collide with anything
   */
  set collidable(state) {
    this._collidable = state;
    if (state) {
      this.add(ConvexColliderComponent.create("collide"), null);
    } else if (this.components("collide") != null) {
      this.remove("collide").destroy();
    }
  }

  /**
   * Returns <tt>true</tt> if the actor can be collided with
   */
  get collidable() {
    return this._collidable;
  }

  /**
   * Set the sprite which represents this actor
   */
  set sprite(sprite) {
    this._sprite = sprite;
    this.boundingBox = sprite.boundingBox;
    this.components("draw").sprite = sprite;

    // Set the collision hull
    this.collisionHull = OBBHull.create(sprite.boundingBox);
  }

  /**
   * Get the sprite which represents this actor
   */
  get sprite() {
    return this._sprite;
  }

  /**
   * Host callback which is triggered when collision occurs between this object and
   * another object.  This will typically trigger an event callback for scripted events.
   * @param collisionObj {Object2D} The object that this object collided with
   * @param time {Number} The time at which the collision occurred
   * @param dt {Number} The delta between the world time and the last time the world was updated
   *          in milliseconds.
   * @param targetMask {Number} The collision mask for the object this collided with
   * @return {Number} Returns a flag which tells the collision system what to do
   */
  onCollide(collisionObj, time, dt, targetMask) {
    var cData = this.components("collide").collisionData;
    var cResult = this.callScriptedEvent("onCollide",
      ["collisionData", "targetMask", "worldTime", "delta"],
      [cData, targetMask, time, dt]);

    // We may want to do something here...
    cResult.poof = "poof";

    return cResult;
  }

  // ---------------------------------------------------------------------
  // Methods intended to be called from scripted actions

  moveLeft(speed) {
    this.setMoveVector(-speed, 0);
  }

  moveRight(speed) {
    this.setMoveVector(speed, 0);
  }

  getSpeedX() {
    return this.moveVector.x;
  }

  getSpeedY() {
    return this.moveVector.y;
  }

  changeDirection() {
    this.moveVector.neg();
  }

  flipRenderX() {
    this.setScale(this.scaleX * -1, this.scaleY);
  }

  flipRenderY() {
    this.setScale(this.scaleX, this.scaleY * -1);
  }

  lastMVec = null;

  stop() {
    this.variables.lastMVec = R.clone(this.moveVector);
    this.setMoveVector(0, 0);
  }

  go() {
    if (this.variables.lastMVec) {
      this.setMoveVector(this.variables.lastMVec);
      this.variables.lastMVec.destroy();
    }
  }

  get moveVector() {
    return this.getComponent("move").moveVector;
  }

  set moveVector(pt) {
    this.getComponent("move").setMoveVector(pt);
  }

}

///**
// * Serialize the sprite actor into an object.
// * @param actor {R.engine.SpriteActor} The object to serialize
// * @param [defaults] {Object} Default values that don't need to be serialized unless
// *    they are different.
// * @return {Object}
// */
//serialize:function (actor, defaults) {
//  defaults = defaults || [];
//  var propObj = R.objects.Object2D.serialize(actor, defaults);
//
//  // Get the actor config
//  var aCfg = {
//    "actorId": actor.getActorId(),
//    "bitMask": actor.getCollisionMask()
//  };
//
//  for (var c in actor.getConfig()) {
//    var val = actor.getConfig()[c] == "var" ? actor.getVariable(c) :
//      (actor.getActorEvent(c) && actor.getActorEvent(c).script ? actor.getActorEvent(c).script : "");
//    if (val) {
//      aCfg[c] = val;
//    }
//  }
//
//  // Add in the actor config
//  propObj.ACTOR_CONFIG = aCfg;
//  return propObj;
//}
//,
//
///**
// * Deserialize the object back into a sprite actor.
// * @param obj {Object} The object to deserialize
// * @param spriteLoaders {Array} An array of sprite loaders
// * @param [clazz] {Class} The object class to populate
// * @return {R.objects.SpriteActor} The object which was deserialized
// */
//deserialize:function (obj, spriteLoaders, clazz) {
//  // Extract the actor config from the object
//  var aCfg = obj.ACTOR_CONFIG;
//  delete obj.ACTOR_CONFIG;
//
//  // Create the class
//  clazz = clazz || R.objects.SpriteActor.create(obj.name);
//  R.objects.Object2D.deserialize(obj, clazz);
//
//  // If the sprite wasn't already found, use the sprite loaders passed to us
//  if (!clazz.getSprite()) {
//    var resourceName = obj.Sprite.split(":")[0], spriteName = obj.Sprite.split(":")[1];
//    for (var sl = 0; sl < spriteLoaders.length; sl++) {
//      if (spriteLoaders[sl].get(resourceName)) {
//        clazz.setSprite(spriteLoaders[sl].getSprite(resourceName, spriteName));
//        break;
//      }
//    }
//  }
//
//  if (!clazz.getSprite()) {
//    throw new ReferenceError("The resource '" + resourceName + "' for sprite '" + spriteName + "' could not be found.");
//  }
//
//  // Repopulate the actor config
//  clazz.setActorId(aCfg.actorId);
//  clazz.setCollisionMask(aCfg.bitMask);
//  delete aCfg.actorId;
//  delete aCfg.bitMask;
//
//  // Events and variables
//  for (var c in aCfg) {
//    var val = clazz.getConfig()[c] == "var" ? clazz.setVariable(c, aCfg[c]) :
//      clazz.setActorEvent(c, aCfg[c]);
//  }
//
//  return clazz;
//}
//})
//;
//}
//;
